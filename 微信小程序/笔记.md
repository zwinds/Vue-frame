# 微信小程序开发
## 文件结构
app.wxss 全局样式，一般把小程序通用的样式写在这里，小程序的每一个页面都可以使用。

pages文件夹下的文件对应小程序的页面，右击项目目录 --> 新建page 即可新建一个页面，每一个页面都由4个文件组成，其中js文件用来处理逻辑，json文件是该页面的文件配置，wxml和wxss用来绘制该页面的UI
## 逻辑层的JavaScript
* 小程序不是运行在浏览器中，所有没有DOM和BOM对象
### 小程序的js有一些额外的成员
* App方法，用于定义应用程序实例对象
* Page方法，用于定义页面对象
* GetApp方法，用来获取全局应用程序对象
* GetCurrentPages方法，用来获取当前页面的调用栈
* wx对象，用来提供核心api
### 小程序的js是支持CommonJS规范的
#### CommonJS模块的特点：
* 1：所有代码都运行在模块作用域，不会污染全局作用域。
* 2：模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
* 3：模块加载的顺序，按照其在代码中出现的顺序。

## mustache语法可以用在
* innerHTML(类似)
* 元素的属性上，不能用在标签名和属性名上

## 基本的循环 wx:for
* 1.明确页面结构中的循环体
* 2.删除多余的重复内容，只保留一个
* 3.在剩下的这个加上wx:for属性，属性值等于要遍历的数据源，数据源必须是一个数组
* 4.在这个标签(循环体)内部使用item代表当前被遍历的元素，给被遍历到的对象定义名称wx:for-item，给遍历的下标(索引)定义名称wx:for-index

## 界面层 事件触发
* 阻止按钮冒泡：catch+事件名 是阻止冒泡并绑定事件

## 界面层 事件传参
* 1、data-名称 不能有大写字母，如果需要，可以通过 - （中划线）来连接单词，编译的时候小程序会将第二个单词首字母自动大写。图中代码是为了自己标志，所以第二个单词的首字母大写了，其实可以不用。data-* 属性中不可以存放对象。

* 2、注意打印结果中target和currentTarget的区别。

* target 触发事件的源组件。
* currentTarget 事件绑定的当前组件。

* 如果你在父容器上绑定了事件并传参，当你点击父容器时，事件绑定的组件和触发事件的源组件是同一个元素，所以currentTarget 、target 都可以拿到参数，但是当你点击子元素时，target 就不是事件绑定的组件了，所以拿不到参数。
由于事件冒泡的机制，父容器上绑定的事件依然可以触发，所以currentTarget 依然可以拿到参数。

* 说明 id传参和dataset类似，只是最后获取值的时候不同。event.currentTarget.id

## 单项数据流
* this.setData是用来改变data中的数据
* 他与直接赋值区别自安于setData可以通知界面做出变化
* 直接赋值没有办法实现这一点(早期的js)

## 条件渲染
* wx:if
* 在框架中，使用 wx:if="" 来判断是否需要渲染该代码块：
```js
<view wx:if="{{condition}}"> True </view>
也可以用 wx:elif 和 wx:else 来添加一个 else 块：

<view wx:if="{{length > 5}}"> 1 </view>
<view wx:elif="{{length > 2}}"> 2 </view>
<view wx:else> 3 </view>
```
block wx:if
因为 wx:if 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 <block/> 标签将多个组件包装起来，并在上边使用 wx:if 控制属性。
```js
<block wx:if="{{true}}">
  <view> view1 </view>
  <view> view2 </view>
</block>
```
* 注意： <block/> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。

* wx:if vs hidden
* 因为 wx:if 之中的模板也可能包含数据绑定，所以当 wx:if 的条件值切换时，框架有一个局部渲染的过程，因为它会确保条件块在切换时销毁或重新渲染。

* 同时 wx:if 也是惰性的，如果在初始渲染条件为 false，框架什么也不做，在条件第一次变成真的时候才开始局部渲染。

* 相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。

* 一般来说，wx:if 有更高的切换消耗而 hidden 有更高的初始渲染消耗。因此，如果需要频繁切换的情景下，用 hidden 更好，如果在运行时条件不大可能改变则wx:if较好。